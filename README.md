## Сделано
### Задача 1 - `Selection Sort`
Мы берем первый элемент массива, и бегаем по всему оставшемуся массиву в поисках числа меньше нашего первого элемента. 
Когда мы пробегаем весь массив, если меньшее число найдено — меняем его местами с первым элементом.
### Задача 2 - `Quick Sort`
Cуть алгоритма заключается в разделении массива на два под-массива, средней линией считается элемент, который находится в самом центре массива. 
В ходе работы алгоритма элементы, меньшие чем средний будут перемещены в лево, а большие в право.
### Задача 3 - `Merge Sort` (узнать простая или естественная)
Сначала делим список на кусочки (по 1 элементу), затем сравниваем каждый элемент с соседним, сортируем и объединяем. 
В итоге, все элементы отсортированы и объединены вместе.
### Задача 4 - `Barrier Search`
Сначала меняем искомый элемент на последний в массиве и идем по массиву пока не встретим этот самый элемент(баррьер).
Так можно избавиться от условия сравнения выхода за пределами массива
### Задача 5 - `Binary Search`
Выбираем опорный элемент. Если искомый элемент больше, чем опорный, то элемент находится с право и левую часть можно отбрасывать, или наоборот.
Повторяем пока не найдем искомый. (только с отсортированными массивами)
### Задача 6 - `Simple String Searching`
Смысл задачи в том, чтобы найти подстроку по шаблону в строке. Мы пробегается по словам и ишем, чтобы первый символ шаблона совпадал с символом строки и только за тем идет проверка остальных символов.


## В процессе
### Задача 7
self = DoubleLinkedList
i = DLLNode
i[0] - DLLNode.value
i[1] - Ссылка на DLLNode
### Задача 8